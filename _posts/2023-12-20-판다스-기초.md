---
title: "판다스 기초"
tags:
  - AICE 자격증 공부
---
# DataFrame 

> 2차원(col, row) 테이블 데이터 구조를 가진 자료형

## 1. 생성 방법
개인적인 메모 : JupyterLab에서 shift+enter 할 시 셀 실행

``` Python3
# pandas import
import pandas as pd
import numpy as np
```
<br>

#### 1. 딕셔너리 활용
   - pandas.DataFrame(딕셔너리) 함수 사용
#### 2. 리스트 활용
   - pandas.DataFrame(리스트) 함수 사용
#### 3. 파일(csv 등) 활용
   - 판다스로 먼저 import
   - DataFrame명 = pandas.read_csv(파라미터)
    - **filepath & buffer** : 파일경로/파일이름.csv
    - **sep & delimiter** : 초기값은 ,(comma)
    - **encoding** : utf8, cp949 etc
    - indexcols : index로 사용할 column 설정
    - usecols : index_col 포함
   - 특정 변수에 제대로 데이터가 들어갔는지 확인하기 위해서 사용<br>
     DataFrame명.head(n=10) : (상위 10개)<br>
     DataFrame명.tail(n=5) : (하위 5개)

### DataFrame 기본함수
- DataFrame명.shape : row, col 개수 튜플로 반환
- DataFrame명.columns : 컬럼명 확인 
- DataFrame명.info : 데이터타입, 아이템 개수 출력
- DataFrame명.describe : 데이터 요약 통계량
- DataFrame명.dtype : 데이터 형태 종류

### 데이터 조회
#### 1. DataFrame에서 [] 형태로 column 선택 (복수선택 가능)
   - Series 형태 DataFrame명.['column']
   - DataFraem 형태 DataFrame명.[['column']]
#### 2. DafaTrame Slicing으로 row 선택
   - DataFrame명.loc : 이름, 라벨 기준으로 슬라이싱, 인덱싱
   - DataFrame명.iloc : 행번호 기준으로 슬라이싱, 인덱싱 (0부터 시작하는 인덱스)
   - bolean selection 연산으로 row 선택
#### 3. DataFrame column 추가, 삭제
   - DataFrame명.insert(loc, **column**, **value**, allow_duplicates=False) : 함수 삽입
   - DataFrame명.drop(**labels=None**, **axis=0**, index=None, columns=None, level=None, **inplace=False**, errors='raise') : 함수 삭제
   - 이때 다른 데이터 프레임에 저장하거나 drop 함수 작성 시 inplace=True를 해야 원본 데이터가 지워진다.

### 기타 함수
- numpy.arange(a, b) a부터 b-1에서 끝나도록 간격을 1로 반환하는 함수

## 2. 변형 방법
### Group by (그룹화)
> 같은 값을 하나로 묶어서 통계 또는 집계 결과를 얻기 위해 사용하는 것, dictionary 형태

1. 데이터분할(split)
2. 적용(applying)
3. 데이터병합(combine)

### pivot, pivot table
> **col와 row**를 중심으로 DataFrame 형태 변경하는 것으로 여러 분류로 섞인 행 데이터를 열 데이터로 회전한다.

- pivot table : aggrefucntion 함수 활용
  pivot 테이블만 가능안 케이스
  1. Index가 2개 이상인 경우
  2. columns가 2개 이상인 경우
  3. 중복 값이 있는 경우
 
### stack, unstack

- stack : 컬럼 레벨에서 인덱스 레벨로 DataFrame 변경
  위에서 아래로 쌓는 개념
- unstack : 인덱스 레벨에서 컬럼 레벨로 변경
  쌓은 것을 옆으로 늘어 놓는 개념

***
### 그룹화 단계
#### groupby, groups
- Groupby
  -DataFrame명.groupby('col')<br>
  파라미터 : col의 리스트&col<br>
  dataframe 객체로 출력
- groupby명.groups : 그룹 속성 확인

```Python3
GP = data.groupby('gender')
```

#### 2. 함수 할용
- groupby명.count() : 데이터 개수
- groupby명.mean() : 집단별 크기<br>
  groupby명.std() : 표준편차<br>
  groupby명.var() : 분산
- groupby명.sum() : 데이터의 합
- groupby명.max() : 데이터의 max값<br>
  groupby명.min() : min값

#### 3.groupby로 이용한 인덱스 설정 후 데이터 추출

```Python3
GP.mean()[['score']]
data('gender').mean()[['score']])
```
두 코드는 모두 같은 결과를 부른다. <br>
1. 이전에 data라는 데이터프레임의 col 'gender'로 그룹화된 GP 중 특정 col 'score' 평균을 성별별로 출력한다.
2. data라는 데이터프레임의 col 'gender' 중 특정 col 'score' 평균을 성별별로 출력한다. (이때 그룹화는 안된 상태)

#### 4.복수 columns를 기준으로 Groupping

```Python3
data.groupby(['department', 'gender']).mean()[['score']]
GP = data.groupby(['department', 'gender'])
GP.mean()[['score']]
```
department, gender를 인덱스로 정한 후 score 평균을 구한다.

```Python3
data.groupby(['department', 'gender']).mean().loc[[("economic", "M")]]
```
#### 5~6. index를 이용한 그룹화 & MultiIndex를 이용한 groupping
```Python3
data.set_index(['department','gender']).groupby(level=[0, 1]).mean()
```
**DataFrame명.set_index(['col1', 'col2'...])** 
- column 데이터를 인덱스 레벨로 변경하여 사용
- 기존의 행 인덱스 제거 및 데이터 열 중 하나를 인덱스로 설정
<br>
**.groupby(level=[i])**
- level : index의 depth, 가장 왼쪽을 0으로 취급하여 증가
- department, gender를 인덱스 레벨로 변경한 후 groupby 함수의 level[0,1 ]으로 통해 index depth가 0인 department와 1인 gender를 각각 순서대로 평균값(mean) 출력

**reset_index 함수**
- 인덱스 초기화
- 기존의 행 인덱스를 제거하고 인덱스를 데이터열로 추가

#### 7. aggregate(집계) 함수 사용
```Python3
data.set_index(['department','gender']).groupby(level=[0, 1]).aggregate([numpy.mean, numpy.max])
```
**aggregate 함수**
- 그룹별 mean, max 등 데이터 확인

### pivot(table) 단계
#### 1. pivot
```Python3
data.pivot(index='인덱스명', columns='열', values='가치')
data.pivot('인덱스명', '열', '가치')
```

#### 2. pivottable
```Python3
data.pivot_table(index='인덱스명', columns='열', values='가치')
```

```Python3
data.pivot_table(index='인덱스명', columns='열', values='가치', aggfunc=numpy.sum)
```
aggfunc = aggregate 함수

### 3. 차이점
```Python3
data.pivot(index=['인덱스1, 인덱스2'], columns='열', values='가치') #에러
data.pivot(index='인덱스명', columns=['열1', '열2'], values='가치') #에러
data.pivot(index='인덱스명', columns='열', values='가치') #중복값 포함 #에러

data.pivot_table(index=['인덱스1, 인덱스2'], columns='열', values='가치')
data.pivot_table(index='인덱스명', columns=['열1', '열2'], values='가치')
data.pivot_table(index='인덱스명', columns='열', values='가치') #중복값 포함
```

### (un)stack 단계
> stack : 컬럼 레벨에서 인덱스 레벨로 DataFrame 변경
>
> unstack : 인덱스 레벨에서 컬럼 레벨로 변경
즉, 해당 단계에서는 컬럼 레벨↔인덱스 레벨 과정이 필요하기 때문에 **set_index** 함수로 데이터프레임 변경

```Python3
DF = data.set_index(['department', 'gender'])
```
department와 gender라는 col을 index로 변경

```Python3
DF.unstack(0)
```
인덱스레벨(깊이)이 0인 department를 col로 이동

```Python3
DF.unstack(0).stack(0)
```
- **unstack(0)** <br>
  인덱스레벨(깊이)아 0인 department를 col로 이동
- **.stack(0)** <br>
  0번째 레벨 col을 인덱스로 이동(1번째 레벨 col은 department다)

```Python3
DF.unstack(0).stack(1)
```
- **.stack(1)** <br>
  1번째 레벨 col을 인덱스로 이동(1번째 레벨 col은 department다) 따라서 department는 다시 인덱스로 이동하면서 바뀐다.


***
## 3. 병합 방법
### concat/merge 함수
> 두개 이상의 DataFrame을 하나로 합치는 경우
- concat 함수 : 데이터 속성이 동일한 데이터 set
- merge 함수 : 두 DataFrame을 공통된 항목<br>
  inner, left, right, outer

#### concat 함수

#### merge 함수
