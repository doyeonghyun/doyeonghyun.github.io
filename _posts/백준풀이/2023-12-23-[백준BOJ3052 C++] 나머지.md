---
title: "[백준BOJ3052 C++] 나머지"
tags:
 - 백준풀이
---
### 문제

[https://www.acmicpc.net/problem/3052](https://www.acmicpc.net/problem/3052)

***

### 풀이
- **배열** 이용

N을 42로 나눈 나머지를 구한 후, 서로 다른 값이 몇 개 있는지 구하는 문제다. 0~41의 값이 나오고, 이 범위에서 겹치는 나머지값이 나올 수 있다. <br/><br/>

예제 입력 2
> 모든 나머지값이 0으로 나오면 1로 카운트하여 1을 출력해야 된다.


예제 입력 3
> 나머지값이 39, 40, 41, 0, 1, 2, 40, 41, 0, 1이 나온다면 0, 1, 40, 41이 중복되기 때문에 카운트하지 않는다. 총 6을 출력해야 한다. (0, 1, 2, 39, 40, 41)


해당 나머지가 어떻게 중복되는지 파악하기 위해서 여러가지 방법을 생각해보았고, 본인이 고른 방법은 **배열의 크기를 42로 생성**한 후 **나머지값 인덱스**에 1씩 더해서 **카운트**한다.<br/><br/>

만약 나머지값이 0이면 arr[0]에 1을 더한다. 나머지값이 41이면 arr[41]에 41를 더한다.<br/><br/> 

이후 총 나머지값을 카운트할 때, **최소 1 이상 카운트 된 요소가 탐색될 경우 나머지값을 카운트** 하여 그 값을 출력하면 정답이 나온다. <br/><br/>

만약 arr[0]의 값이 10이고 이후에 1 이상 카운트된 요소가 없어서 총 나머지값은 1개다.

***
### 제출
```C++17
#include <iostream>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int N;
    int cnt = 0;
    int ans[42] = { 0 };

    for (int i = 0; i < 10; i++) {
        cin >> N;
        ans[N % 42] += 1;
    }

    for (int i = 0; i < 42; i++) {
        if (ans[i] >= 1) cnt += 1;
    }

    cout << cnt;

    return 0;
}
```

***

### 메모
- 공통된 방법은 **배열**을 이용한다는 점.<br/>
  배열을 활용하여 서로 다른 값의 개수를 찾기 위해서는, 입력값보다는 계산 후 나오는 결과값을 배열에 저장하여 중복값을 찾는 작업을 하는게 효율적이다. 


시도한 방법
> 1. 10번 입력받기 때문에 배열의 크기를 10으로 생성한다. 이후 입력할 때마다 인덱스에 나머지값을 삽입하고 1씩 증가시킨다.(for문) 이후 나머지값이 들어간 배열 안에서 서로의 값을 비교한다. 이때 비교하는 방법은 배열의 현재 요소와 다음 요소를 서로 비교한다.<br/><br/>
>
> 2. 그러나 이 풀이는 현재 요소를 전체 요소와 비교해야 된다는 사실을 망각했다.<br/><br/>
> 
> 3. 현재 요소를 어떻게 전체 요소와 비교하여 중복되는 나머지값을 찾아야할지 고민하는 과정에서 다양한 방법을 사용해보았지만, 원하는 답이 나오지 않아 배열을 다르게 정의해야 됨을 깨닫는다.<br/><br/>
> 
> 4. 배열의 크기를 10으로 생성하여 입력값마다 삽입하지 않고, 배열의 크기를 1000으로 생성하여 입력받은 숫자에 해당하는 인덱스의 요소에 삽입한 후 비교한다.<br/><br/>
> 
> 5. 차라리 나머지값에 해당하는 인덱스의 요소에 카운트하여 나머지값을 찾는게 효율적이라고 깨닫고 배열의 크기를 42로 생성한 후 풀이대로 작성.
